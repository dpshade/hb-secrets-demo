diff --git a/.gitignore b/.gitignore
index 013c106..2a83718 100644
--- a/.gitignore
+++ b/.gitignore
@@ -90,4 +90,7 @@ Thumbs.db
 
 # Temporary files
 *.tmp
-*.temp
\ No newline at end of file
+*.temp
+
+# Crush database
+.crush/
diff --git a/ROADMAP.md b/ROADMAP.md
index 61eebee..fbe2623 100644
--- a/ROADMAP.md
+++ b/ROADMAP.md
@@ -26,11 +26,11 @@
    - Simple "Change Username" option
 
 2. **Wallet Persistence & Export**
-   - Fix wallet resetting on page refresh (use whoami ping)
-   - Show the same generated wallet address consistently
-   - Export wallet capability for backup/portability
-   - Demonstrate that HyperBEAM generates stable identities
-   - Clear indication this is auto-generated (no external wallet needed)
+   - ✅ Fix wallet resetting on page refresh (use whoami ping)
+   - ✅ Show the same generated wallet address consistently
+   - ❌ Export wallet capability for backup/portability (not working)
+   - ✅ Demonstrate that HyperBEAM generates stable identities
+   - ✅ Clear indication this is auto-generated (no external wallet needed)
 
 **Files to Modify**:
 - `js/auth.js` - Add localStorage username persistence
@@ -100,14 +100,14 @@
 **Sprint Goal**: Polish the demo with persistent identity
 
 **Tasks**:
-1. [ ] Implement username localStorage persistence
-2. [ ] Fix wallet resetting on refresh (use whoami ping)
-3. [ ] Add export wallet capability
-4. [ ] Update statistics to be live/generated by HyperBEAM process
-5. [ ] Update UI to show "auto-generated" wallet status
+1. ✅ Implement username localStorage persistence
+2. ✅ Fix wallet resetting on refresh (use whoami ping)
+3. ❌ Add export wallet capability (not working)
+4. ❌ Update statistics to be live/generated by HyperBEAM process (still static)
+5. ✅ Update UI to show "auto-generated" wallet status
 6. [ ] Add "Reset Demo" functionality
-7. [ ] Improve messaging about HyperBEAM secrets device
-8. [ ] Test demo flow from fresh browser
+7. ✅ Improve messaging about HyperBEAM secrets device
+8. ✅ Test demo flow from fresh browser
 
 **Estimated Timeline**: 1-2 days
 **Priority**: High - Essential for demo continuity
diff --git a/debug-stats.html b/debug-stats.html
new file mode 100644
index 0000000..39025ba
--- /dev/null
+++ b/debug-stats.html
@@ -0,0 +1,62 @@
+<!DOCTYPE html>
+<html>
+<head>
+    <title>Debug Statistics</title>
+    <script src="config.js"></script>
+    <script src="js/hyperbeam-api.js"></script>
+    <script src="js/auth.js"></script>
+    <script src="js/chat-history.js"></script>
+    <script src="js/chat.js"></script>
+</head>
+<body>
+    <h3>Statistics Debug</h3>
+    <div id="debug-output"></div>
+    
+    <script>
+        async function debugStats() {
+            const output = document.getElementById('debug-output');
+            
+            try {
+                // Initialize systems
+                const api = new HyperBEAMAPI(CONFIG);
+                const auth = new AuthSystem(CONFIG);
+                
+                // Generate or load wallet
+                await auth.initialize();
+                const authData = await auth.getAuthenticationData();
+                
+                output.innerHTML += `<p><strong>Wallet Address:</strong> ${authData.walletAddress}</p>`;
+                
+                // Initialize chat system
+                const chatSystem = new ChatSystem(api, auth);
+                
+                // Load chat history
+                await chatSystem.loadChatHistory();
+                
+                // Get statistics
+                const stats = await chatSystem.getStats();
+                
+                output.innerHTML += `<h4>Statistics:</h4>`;
+                output.innerHTML += `<p>Total Messages: ${stats.totalMessages}</p>`;
+                output.innerHTML += `<p>Messages by Current Wallet: ${stats.messagesByCurrentWallet}</p>`;
+                output.innerHTML += `<p>Messages from Others: ${stats.messagesFromOthers}</p>`;
+                output.innerHTML += `<p>Received Messages Count: ${stats.receivedMessagesCount}</p>`;
+                output.innerHTML += `<p>Current Wallet Address: ${stats.currentWalletAddress}</p>`;
+                output.innerHTML += `<p>Pending Messages: ${stats.pendingMessages}</p>`;
+                
+                output.innerHTML += `<h4>Messages:</h4>`;
+                chatSystem.messages.forEach((msg, i) => {
+                    output.innerHTML += `<p>${i+1}. "${msg.content}" by ${msg.author} (wallet: ${msg.walletAddress || 'none'}) - Status: ${msg.status}</p>`;
+                });
+                
+            } catch (error) {
+                output.innerHTML += `<p style="color: red;"><strong>Error:</strong> ${error.message}</p>`;
+                console.error('Debug error:', error);
+            }
+        }
+        
+        // Run debug on page load
+        debugStats();
+    </script>
+</body>
+</html>
\ No newline at end of file
diff --git a/index.html b/index.html
index fd1dd41..0ebd406 100644
--- a/index.html
+++ b/index.html
@@ -1791,18 +1791,18 @@
                 this.auth = new AuthSystem(this.api);
                 CONFIG.log('Authentication system initialized');
                 
-                // Initialize chat system with pagination
-                this.chat = new ChatSystem(this.api, this.auth);
-                this.chat.initialize(
+                // Initialize chat system
+                this.chatSystem = new ChatSystem(this.api, this.auth);
+                this.chat = this.chatSystem; // Keep backward compatibility
+                
+                this.chatSystem.initialize(
                     this.elements.messages,
                     (message, type) => this.updateStatus(message, type)
                 );
                 
                 // Set initial pagination parameters
-                this.chat.chatHistory.maxSlots = this.pagination.maxHistorySlots;
+                this.chatSystem.chatHistory.maxSlots = this.pagination.maxHistorySlots;
                 CONFIG.log('Chat system initialized');
-                
-                // Set up chat event listeners
                 this.chat.on('messageSent', (data) => this.onMessageSent(data));
                 this.chat.on('messageReceived', (data) => this.onMessageReceived(data));
                 this.chat.on('executionComplete', (data) => this.onExecutionComplete(data));
@@ -1859,6 +1859,11 @@
                         this.auth.updateWalletAddress(walletAddress);
                     }
                     
+                    // Re-evaluate message ownership with new wallet address
+                    if (this.chatSystem) {
+                        this.chatSystem.reloadChatHistory();
+                    }
+                    
                     // Update auth status and UI indicators
                     this.updateAuthStatus(true, {
                         walletAddress: walletAddress,
@@ -2177,7 +2182,7 @@
                     
                     if (result.success) {
                         input.value = '';
-                        this.stats.sent++;
+                        // Stats will be updated from chat system by updateStatsWithAnimation
                         this.updateStatsWithAnimation('sent');
                         
                         this.updateStatus('Message delivered', 'connected');
@@ -2281,6 +2286,10 @@
                 if (authenticated && authData.walletAddress) {
                     let displayAddress;
                     
+                    // Check if wallet address has actually changed to prevent unnecessary reloads
+                    const currentWalletAddress = this.auth?.getWalletAddress();
+                    const walletChanged = currentWalletAddress !== authData.walletAddress;
+                    
                     // Special handling for auto-generated addresses
                     if (authData.walletAddress === 'auto-generated') {
                         displayAddress = 'auto-generated';
@@ -2304,6 +2313,14 @@
                     
                     // Update HyperBEAM status to show successful connection
                     this.updateHyperBEAMStatus('connected', 'HyperBEAM Connected');
+                    
+                    // Only reload chat history if wallet address actually changed
+                    if (this.chatSystem && walletChanged) {
+                        CONFIG.log('Wallet address changed, reloading chat history');
+                        this.chatSystem.reloadChatHistory();
+                    } else if (!walletChanged) {
+                        CONFIG.log('Wallet address unchanged, skipping chat history reload');
+                    }
                 } else {
                     walletDisplay.textContent = 'No wallet';
                     walletDisplay.title = '';
@@ -2319,32 +2336,36 @@
             
             
             onMessageSent(data) {
-                this.stats.sent++;
                 this.updateStats();
                 CONFIG.debug('Message sent:', data);
             }
             
             onMessageReceived(data) {
-                this.stats.received++;
                 this.updateStats();
                 CONFIG.debug('Message received:', data);
             }
             
             onExecutionComplete(data) {
-                this.stats.pending = Math.max(0, this.stats.pending - 1);
                 this.updateStats();
                 CONFIG.debug('Execution complete:', data);
             }
             
             updateStats() {
+                if (this.chatSystem) {
+                    const stats = this.chatSystem.getStats();
+                    this.stats.sent = stats.sent;
+                    this.stats.received = stats.received;
+                    this.stats.pending = stats.pending;
+                    this.stats.total = stats.total;
+                }
+                
                 this.elements['stat-sent'].textContent = this.stats.sent;
                 this.elements['stat-received'].textContent = this.stats.received;
                 this.elements['stat-pending'].textContent = this.stats.pending;
-                this.stats.total = this.stats.sent + this.stats.received;
                 this.elements['stat-total'].textContent = this.stats.total;
             }
             
-            updateStatsWithAnimation(statType) {
+            async updateStatsWithAnimation(statType) {
                 // Update the stat with a delightful animation
                 const statElement = this.elements[`stat-${statType}`];
                 const statItem = statElement.closest('.stat-item');
diff --git a/js/auth.js b/js/auth.js
index 53bee47..8387e1d 100644
--- a/js/auth.js
+++ b/js/auth.js
@@ -482,12 +482,22 @@ class AuthSystem {
     updateWalletAddress(walletAddress) {
         if (!walletAddress) return;
         
+        // Check if wallet address has actually changed
+        const currentWalletAddress = this.authState.walletAddress;
+        const walletChanged = currentWalletAddress !== walletAddress;
+        
         this.config.log('Updating wallet address in auth state:', walletAddress);
-        this.authState.walletAddress = walletAddress;
-        this.authState.lastActivity = Date.now();
         
-        // Use the same persistAuthState method for consistency
-        this.persistAuthState();
+        if (walletChanged) {
+            this.config.log('Wallet address actually changed, updating state');
+            this.authState.walletAddress = walletAddress;
+            this.authState.lastActivity = Date.now();
+            
+            // Use the same persistAuthState method for consistency
+            this.persistAuthState();
+        } else {
+            this.config.log('Wallet address unchanged, skipping state update');
+        }
     }
 
     /**
diff --git a/js/chat.js b/js/chat.js
index 6bff244..e1933d9 100644
--- a/js/chat.js
+++ b/js/chat.js
@@ -113,44 +113,8 @@ class ChatSystem {
 
         try {
             // Create message object with pending state
-            const message = {
-                id: messageId,
-                content: messageContent,
-                timestamp: timestamp,
-                author: username,
-                status: 'pending',
-                method: 'direct-push',
-                isPending: true,
-                walletAddress: this.auth.getWalletAddress()
-            };
-            
-            // No longer using hash-based deduplication
-
-            // Add to messages immediately (optimistic update) with pending state
-            this.addMessage(message);
-            
-            // Set a timeout to auto-confirm if no confirmation comes back
-            setTimeout(() => {
-                const stillPendingMessage = this.messages.find(m => m.id === messageId && m.isPending);
-                if (stillPendingMessage) {
-                    this.config.debug(`Auto-confirming message ${messageId} after timeout`);
-                    
-                    // Update message properties
-                    stillPendingMessage.status = 'confirmed';
-                    stillPendingMessage.isPending = false;
-                    stillPendingMessage.source = 'auto-confirmed';
-                    
-                    // Update UI element smoothly
-                    if (this.messageContainer) {
-                        const messageEl = this.messageContainer.querySelector(`[data-message-id="${messageId}"]`);
-                        if (messageEl) {
-                            messageEl.classList.remove('pending');
-                            messageEl.classList.add('confirmed');
-                            this.updateMessageElement(messageEl, stillPendingMessage);
-                        }
-                    }
-                }
-            }, 15000); // 15 second timeout
+            // SIMPLIFIED: No optimistic UI, no pending messages
+            // Just send and let polling display the computed result
 
             // Send using direct push method including username as a tag
             const result = await this.api.pushMessage(messageContent, 'chat-message', {
@@ -195,25 +159,21 @@ class ChatSystem {
                     }
                 }));
                 
-                // IMMEDIATELY check slots and replace pending message with computed result
-                this.checkForNewMessagesAndReplacePending(messageId, messageContent, username);
-                
-                this.emit('messageSent', { message, result });
+                // SIMPLIFIED: Just let normal polling handle display
+                this.emit('messageSent', { content: messageContent, result });
                 
                 return { success: true, method: 'direct-push', response: result };
                 
             } else {
                 const error = result.error || result.statusText || 'Unknown error';
-                this.updateMessageStatus(messageId, 'failed', { error });
                 this.updateStatus(`Send failed: ${error}`, 'error');
-                this.emit('error', { message, error });
+                this.emit('error', { content: messageContent, error });
                 
                 return { success: false, error };
             }
 
         } catch (error) {
-            this.config.log(`Message ${messageId} send error:`, error);
-            this.updateMessageStatus(messageId, 'failed', { error: error.message });
+            this.config.log(`Message send error:`, error);
             this.updateStatus(`Send error: ${error.message}`, 'error');
             return { success: false, error: error.message };
         }
@@ -248,97 +208,85 @@ class ChatSystem {
         this.config.log('Message polling stopped');
     }
 
+
+
     /**
-     * Check for new messages and smoothly confirm pending message with computed result
+     * Check for new messages and slot advancement
      */
-    async checkForNewMessagesAndReplacePending(pendingMessageId, messageContent, username) {
+    async checkForNewMessages() {
         try {
-            // Wait a brief moment for the message to be processed
-            await new Promise(resolve => setTimeout(resolve, 500));
-            
-            // Check current slot and get latest messages
             const currentSlot = await this.api.getCurrentSlot();
-            const latestMessages = await this.chatHistory.getLatestMessages(3);
             
-            // Look for our message in the latest results
-            const computedMessage = latestMessages.find(msg => 
-                msg.content === messageContent && 
-                (msg.tags?.username === username || msg.tags?.Username === username || msg.username === username)
-            );
-            
-            if (computedMessage) {
-                this.config.debug(`Found computed message for pending ${pendingMessageId}:`, computedMessage);
+            if (currentSlot !== null && currentSlot > this.lastKnownSlot) {
+                this.config.log(`Slot advanced: ${this.lastKnownSlot} → ${currentSlot}`);
                 
-                // Update the existing pending message in-place to confirmed state
-                const pendingMessage = this.messages.find(m => m.id === pendingMessageId);
-                if (pendingMessage) {
-                    // Generate the new ID that matches what polling system expects
-                    const newId = `history-${computedMessage.slot}-${computedMessage.reference}`;
-                    
-                    // Update message properties with slot information
-                    pendingMessage.id = newId; // Critical: update ID to prevent duplicates
-                    pendingMessage.status = 'confirmed';
-                    pendingMessage.isPending = false;
-                    pendingMessage.slot = computedMessage.slot;
-                    pendingMessage.reference = computedMessage.reference;
-                    pendingMessage.source = 'chat-history-confirmed';
-                    
-                    // Update UI element smoothly
-                    if (this.messageContainer) {
-                        const messageEl = this.messageContainer.querySelector(`[data-message-id="${pendingMessageId}"]`);
-                        if (messageEl) {
-                            // Update the data attribute to match new ID
-                            messageEl.setAttribute('data-message-id', newId);
-                            
-                            // Remove pending state and add confirmed state
-                            messageEl.classList.remove('pending');
-                            messageEl.classList.add('confirmed');
-                            
-                            // Update the message element content if needed
-                            this.updateMessageElement(messageEl, pendingMessage);
-                        }
-                    }
-                    
-                    this.config.debug(`Smoothly confirmed pending message ${pendingMessageId} -> ${newId} with computed result`);
-                } else {
-                    this.config.debug(`Could not find pending message ${pendingMessageId} to confirm`);
-                }
-            } else {
-                this.config.debug(`No computed message found yet for pending ${pendingMessageId}, will auto-confirm on timeout`);
+                // FIXED: Only check new slots, don't reload everything
+                await this.addNewMessagesFromSlots(this.lastKnownSlot + 1, currentSlot);
+                
+                this.lastKnownSlot = currentSlot;
             }
             
         } catch (error) {
-            this.config.debug('Error checking for computed messages:', error);
+            this.config.debug('Error checking for messages:', error);
         }
     }
 
-
     /**
-     * Check for new messages and slot advancement
+     * Add new messages from specific slot range without reloading everything
      */
-    async checkForNewMessages() {
+    async addNewMessagesFromSlots(fromSlot, toSlot) {
         try {
-            const currentSlot = await this.api.getCurrentSlot();
+            const newMessages = [];
             
-            if (currentSlot !== null && currentSlot > this.lastKnownSlot) {
-                this.config.log(`Slot advanced: ${this.lastKnownSlot} → ${currentSlot}`);
+            // Check each new slot for messages
+            for (let slot = fromSlot; slot <= toSlot; slot++) {
+                const slotMessages = await this.chatHistory.getMessagesFromSlot(slot);
                 
-                // Check for new messages in advanced slots
-                for (let slot = this.lastKnownSlot + 1; slot <= currentSlot; slot++) {
-                    await this.checkSlotForMessages(slot);
+                if (slotMessages.length > 0) {
+                    this.config.debug(`Found ${slotMessages.length} new messages in slot ${slot}`);
+                    
+                    for (const slotMessage of slotMessages) {
+                        const messageId = `history-${slotMessage.slot}-${slotMessage.reference}`;
+                        
+                        // Check if we already have this message
+                        if (!this.messages.find(m => m.id === messageId)) {
+                            const newMessage = {
+                                id: messageId,
+                                content: slotMessage.content,
+                                timestamp: slotMessage.timestamp,
+                                author: slotMessage.username || 'Chat User',
+                                status: 'confirmed',
+                                slot: slotMessage.slot,
+                                reference: slotMessage.reference,
+                                source: 'slot-polling',
+                                walletAddress: slotMessage.walletAddress
+                            };
+                            
+                            newMessages.push(newMessage);
+                        }
+                    }
                 }
+            }
+            
+            if (newMessages.length > 0) {
+                // Add new messages to existing array
+                this.messages.push(...newMessages);
                 
-                // Also refresh chat history to catch any missed messages
-                await this.refreshLatestHistory();
+                // Sort all messages chronologically 
+                this.messages.sort((a, b) => {
+                    if (a.timestamp !== b.timestamp) return a.timestamp - b.timestamp;
+                    if (a.slot !== b.slot) return a.slot - b.slot;
+                    return parseInt(a.reference || '0') - parseInt(b.reference || '0');
+                });
                 
-                this.lastKnownSlot = currentSlot;
+                // Display all messages (this will show new ones at bottom)
+                this.displayMessages(this.messages);
                 
-                // Update any pending messages that might have executed
-                this.checkPendingMessages(currentSlot);
+                this.config.log(`Added ${newMessages.length} new messages dynamically`);
             }
             
         } catch (error) {
-            this.config.debug('Error checking for messages:', error);
+            this.config.debug('Error adding new messages from slots:', error);
         }
     }
 
@@ -427,7 +375,7 @@ class ChatSystem {
     async prepareHistoryMessage(historyMessage) {
         this.config.debug(`Preparing history message from slot ${historyMessage.slot}:`, historyMessage.content);
 
-        // Extract username from message metadata/tags (now properly stored by AO process)
+        // Extract username from message metadata/tags (what was stored when sent)
         let username = 'Chat User'; // Default username
         
         if (historyMessage.tags && historyMessage.tags.username) {
@@ -448,50 +396,24 @@ class ChatSystem {
             messageWalletAddress = historyMessage.walletAddress;
         }
         
-        // Get current user info for comparison
-        const usernameInput = document.getElementById('username-input');
-        const currentUsername = usernameInput?.value?.trim() || 'Chat User';
-        const currentWalletAddress = this.auth.getWalletAddress();
-        
-        this.config.debug(`Preparing history: '${historyMessage.content}' from '${username}' (wallet: ${messageWalletAddress}), current user: '${currentUsername}' (wallet: ${currentWalletAddress})'`);
-        
-        // Check if this message is from the current user - prioritize wallet address comparison
-        let isOwnMessage = false;
-        if (messageWalletAddress && currentWalletAddress && 
-            messageWalletAddress !== 'auto-generated' && currentWalletAddress !== 'auto-generated' &&
-            messageWalletAddress.length === 43 && currentWalletAddress.length === 43) {
-            // Use wallet address comparison when both are valid 43-char addresses
-            isOwnMessage = messageWalletAddress === currentWalletAddress;
-            this.config.debug(`History message own check via wallet: ${isOwnMessage} (${messageWalletAddress} vs ${currentWalletAddress})`);
-        } else {
-            // Fallback to username comparison
-            isOwnMessage = username === currentUsername;
-            this.config.debug(`History message own check via username: ${isOwnMessage} (${username} vs ${currentUsername})`);
-        }
-        
-        // If this message is from the current user, check for existing message
-        if (isOwnMessage) {
-            // Find existing message with same slot/reference to avoid duplicates
-            const existing = this.messages.find(m => 
-                m.slot === historyMessage.slot && 
-                m.reference === historyMessage.reference
-            );
-
-            if (existing) {
-                this.config.debug('Own history message already processed; skipping');
-                return null;
-            }
-            
-            // Don't merge with pending messages - they should be handled by checkForNewMessagesAndReplacePending
+        // Check for existing message to avoid duplicates
+        const existing = this.messages.find(m => 
+            m.slot === historyMessage.slot && 
+            m.reference === historyMessage.reference
+        );
+
+        if (existing) {
+            this.config.debug('History message already processed; skipping');
+            return null;
         }
         
-        // This is a new message from someone else - prepare it
+        // Prepare the message with the username that was stored in the slot
         const processMessage = {
             id: `history-${historyMessage.slot}-${historyMessage.reference}`,
             content: historyMessage.content,
             timestamp: historyMessage.timestamp,
-            author: username,
-            status: 'received',
+            author: username, // This is what other users see
+            status: 'confirmed',
             slot: historyMessage.slot,
             reference: historyMessage.reference,
             source: 'chat-history',
@@ -897,49 +819,18 @@ class ChatSystem {
     updateMessageElement(messageEl, message) {
         const timestamp = new Date(message.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
         
-        // Determine if this is own message using multiple methods
-        let isOwnMessage = false;
-        
-        // Get current user info for comparison
+        // Simple ownership check - just compare wallet addresses
         const currentWalletAddress = this.auth.getWalletAddress();
-        const usernameInput = document.getElementById('username-input');
-        const currentUsername = usernameInput?.value?.trim() || 'Chat User';
-        
-        // Method 1: Wallet address comparison (most reliable)
-        if (message.walletAddress && currentWalletAddress && 
-            message.walletAddress !== 'auto-generated' && currentWalletAddress !== 'auto-generated' &&
-            message.walletAddress.length === 43 && currentWalletAddress.length === 43) {
-            isOwnMessage = message.walletAddress === currentWalletAddress;
-            this.config.debug(`Own message check via wallet: ${message.walletAddress === currentWalletAddress} (${message.walletAddress} vs ${currentWalletAddress})`);
-        } 
-        // Method 2: Method/source-based detection (for sent messages)
-        else if (message.method === 'direct-push' || (message.source && message.source !== 'chat-history')) {
-            isOwnMessage = true;
-            this.config.debug(`Own message check via method/source: true (${message.method || message.source})`);
-        }
-        // Method 3: Username comparison (fallback)
-        else if (message.author && currentUsername && message.author === currentUsername) {
-            isOwnMessage = true;
-            this.config.debug(`Own message check via username: true (${message.author} === ${currentUsername})`);
-        }
-        
-        this.config.debug(`Final own message determination: ${isOwnMessage} for message from ${message.author} (wallet: ${message.walletAddress})`);
+        const isOwnMessage = message.walletAddress === currentWalletAddress;
         
         messageEl.classList.toggle('own-message', isOwnMessage);
         messageEl.classList.toggle('process-message', !isOwnMessage);
         
-        // Get username, fallback to defaults
-        let username = message.author || (isOwnMessage ? 'You' : 'System');
+        // Use the username that was stored with the message (what others see)
+        // This comes from the slot's computed result, not the current input
+        let username = message.author || 'Chat User';
         
-        // For own messages, show current username instead of 'You' to be consistent
-        if (isOwnMessage && currentUsername && currentUsername !== 'Chat User') {
-            username = currentUsername;
-        }
-        
-        // Remove all grouping logic for minimal style
-        messageEl.classList.remove('grouped', 'last-in-group');
-        
-        // Format: username • timestamp: content (no status text - we use visual states)
+        // Format: username • timestamp: content
         messageEl.innerHTML = `
             <span class="message-header">
                 <span class="message-username">${this.escapeHtml(username)}</span><span class="message-separator">•</span><span class="message-timestamp">${timestamp}</span><span class="message-colon">:</span>
@@ -1079,24 +970,20 @@ class ChatSystem {
                 return;
             }
             
-            // Step 2: Process and prepare ALL messages without displaying them
+            // Step 2: Process messages for display
             const processedMessages = [];
-            const chronologicalMessages = historyMessages.slice().reverse();
-            
-            for (const historyMessage of chronologicalMessages) {
+            for (const historyMessage of historyMessages) {
                 const processedMessage = await this.prepareHistoryMessage(historyMessage);
                 if (processedMessage) {
                     processedMessages.push(processedMessage);
                 }
             }
             
-            // Step 3: Sort all processed messages
+            // Step 3: Sort messages chronologically
             processedMessages.sort((a, b) => {
-                // Sort by timestamp primarily
                 if (a.timestamp !== b.timestamp) {
                     return a.timestamp - b.timestamp;
                 }
-                // If timestamps are same, sort by slot then reference
                 if (a.slot !== b.slot) {
                     return a.slot - b.slot;
                 }
@@ -1112,6 +999,7 @@ class ChatSystem {
         } catch (error) {
             this.config.log('Error loading chat history:', error);
             await this.hideLoadingSkeleton();
+            this.showEmptyState();
             this.updateStatus('Failed to load chat history', 'error');
         }
     }
@@ -1133,6 +1021,23 @@ class ChatSystem {
         await this.loadChatHistory();
     }
     
+    /**
+     * Reload chat history when wallet connects - resets message counter to avoid double counting
+     */
+    async reloadChatHistory() {
+        // Clear current messages
+        this.messages = [];
+        if (this.messageContainer) {
+            this.messageContainer.innerHTML = '';
+        }
+        
+        // Clear chat history cache
+        this.chatHistory.clearCache();
+        
+        // Reload history
+        await this.loadChatHistory();
+    }
+    
     /**
      * Refresh only the latest messages (more efficient for slot advancement)
      */
@@ -1173,7 +1078,7 @@ class ChatSystem {
                 // Display all messages in sorted order
                 this.displayMessages(allMessages);
                 
-                this.config.debug(`Added ${newMessages.length} new messages from latest history`);
+                this.config.debug(`Added ${newMessages.length} new messages`);
             }
         } catch (error) {
             this.config.debug('Error refreshing latest history:', error);
@@ -1185,33 +1090,36 @@ class ChatSystem {
      */
     clearChatHistory() {
         this.messages = [];
-        // Removed hash tracking
+        this.chatHistory.clearCache();
+        
         if (this.messageContainer) {
             this.messageContainer.innerHTML = '';
+            this.showEmptyState();
         }
-        this.config.log('Chat history cleared');
     }
 
     /**
-     * Get chat statistics
+     * Get simple chat statistics
      */
-    async getStats() {
-        const statusCounts = this.messages.reduce((counts, msg) => {
-            counts[msg.status] = (counts[msg.status] || 0) + 1;
-            return counts;
-        }, {});
+    getStats() {
+        const currentWalletAddress = this.auth.getWalletAddress();
+        let sent = 0, received = 0, pending = 0;
+        
+        this.messages.forEach(msg => {
+            if (msg.isPending || msg.status === 'pending') {
+                pending++;
+            } else if (msg.walletAddress === currentWalletAddress) {
+                sent++;
+            } else {
+                received++;
+            }
+        });
         
-        // Get chat history stats
-        const historyStats = await this.chatHistory.getStats();
-
         return {
-            totalMessages: this.messages.length,
-            statusCounts,
-            lastKnownSlot: this.lastKnownSlot,
-            pendingMessages: this.pendingMessages.size,
-            isPolling: this.isPolling,
-            lastMessageId: this.lastMessageId,
-            historyStats: historyStats
+            sent,
+            received, 
+            pending,
+            total: this.messages.length
         };
     }
 
